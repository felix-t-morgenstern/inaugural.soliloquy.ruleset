package inaugural.soliloquy.ruleset.gameconcepts;

import org.javatuples.Triplet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import soliloquy.specs.common.valueobjects.Coordinate2d;
import soliloquy.specs.common.valueobjects.Coordinate3d;
import soliloquy.specs.common.valueobjects.Pair;
import soliloquy.specs.gamestate.entities.GameZone;
import soliloquy.specs.gamestate.entities.Tile;
import soliloquy.specs.gamestate.entities.WallSegment;
import soliloquy.specs.gamestate.entities.WallSegmentOrientation;
import soliloquy.specs.ruleset.entities.GroundType;
import soliloquy.specs.ruleset.entities.WallSegmentType;
import soliloquy.specs.ruleset.gameconcepts.TileVisibilityRayCalculation;

import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

import static inaugural.soliloquy.tools.collections.Collections.*;
import static inaugural.soliloquy.tools.random.Random.randomIntInRange;
import static inaugural.soliloquy.tools.random.Random.randomIntWithInclusiveCeiling;
import static inaugural.soliloquy.tools.valueobjects.Coordinate2d.addOffsets2d;
import static inaugural.soliloquy.tools.valueobjects.Coordinate3d.addOffsets3d;
import static inaugural.soliloquy.tools.valueobjects.Pair.pairOf;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static soliloquy.specs.gamestate.entities.WallSegmentOrientation.*;
import static soliloquy.specs.ruleset.gameconcepts.TileVisibilityCalculation.Result;

// Coordinates used for testing tiles to run over were generated by creating a line in a graphing
// calculator which intersects the offset of the target from the origin. Each tile's location can
// be treated as the intersections between whole-number values on the axes, with the segments at
// the +/-0.5 boundaries. When the line intersecting the target offset tile's location crosses a
// 0.5 boundary, again representing crossing a segment plane from one 2d coordinate to another,
// that is treated as a testing requirement for the visibility ray's cursor to move to that 2d
// location from its previous location.
@RunWith(MockitoJUnitRunner.class)
public class TileVisibilityRayCalculationImplTests {

    // Z values must be within a reasonable value, to avoid bizarre rounding errors
    private final int Z = randomIntInRange(-10000, 10000);
    private final float Z_ADDEND_BELOW = 10;

    @Mock private Supplier<GameZone> mockGetGameZone;
    @Mock private Supplier<Integer> mockGetViewCeiling;
    @Mock private Supplier<Integer> mockGetViewFloor;
    @Mock private GameZone mockGameZone;
    @Mock private GroundType mockGroundTypeTransparent;
    @Mock private GroundType mockGroundTypeBlocking;

    private List<Pair<Coordinate3d, Tile>> tilesReturned;
    private List<Triplet<WallSegmentOrientation, Coordinate3d, WallSegment>> segmentsReturned;
    private Map<Integer, WallSegment> segmentReturnOverrides;
    private int segmentGenCounter;
    // NB: These are only relevant in line-of-sight blocking tests, since segments will need to
    // be at specific locations to not potentially overlap
    private boolean movingEast;
    private boolean movingSouth;

    private TileVisibilityRayCalculation rayCalculation;

    @Before
    public void setUp() {
        tilesReturned = listOf();
        segmentsReturned = listOf();
        segmentReturnOverrides = mapOf();
        segmentGenCounter = 0;
        movingEast = movingSouth = false;

        when(mockGameZone.getSegments(any())).thenAnswer(invocation -> {
            var index = segmentGenCounter++;
            WallSegment mockSegment;
            if (segmentReturnOverrides.containsKey(index)) {
                mockSegment = segmentReturnOverrides.get(index);
            }
            else {
                var orientation = WallSegmentOrientation.fromValue(randomIntInRange(1, 3));
                Coordinate2d segLoc = invocation.getArgument(0);
                var segLocX = segLoc.X + (movingEast ? 1 : 0);
                var segLocY = segLoc.Y + (movingSouth ? 1 : 0);
                mockSegment =
                        makeMockSegment(orientation, Coordinate3d.of(segLocX, segLocY, Z), false);
            }
            var orientation = mockSegment.getType().orientation();
            var loc = mockSegment.location();
            segmentsReturned.add(Triplet.with(orientation, loc, mockSegment));
            Map<WallSegmentOrientation, Map<Coordinate3d, WallSegment>> segmentsMap = mapOf();
            // GameZone::getSegments is assumed to return a non-null map for each orientation
            segmentsMap.put(HORIZONTAL, mapOf());
            segmentsMap.put(CORNER, mapOf());
            segmentsMap.put(VERTICAL, mapOf());
            segmentsMap.get(orientation).put(loc, mockSegment);
            return segmentsMap;
        });
        when(mockGameZone.tiles(any())).thenAnswer(invocation -> setOf(
                makeMockTile(((Coordinate2d) invocation.getArgument(0)).to3d(Z), false)));
        when(mockGetGameZone.get()).thenReturn(mockGameZone);

//        when(mockGetViewCeiling.get()).thenReturn(null);
//        when(mockGetViewFloor.get()).thenReturn(null);

        when(mockGroundTypeBlocking.blocksSight()).thenReturn(true);
        when(mockGroundTypeTransparent.blocksSight()).thenReturn(false);

        rayCalculation = new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                mockGetViewFloor, Z_ADDEND_BELOW);
    }

    @Test
    public void testConstructorWithInvalidParams() {
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(null, mockGetViewCeiling,
                        mockGetViewFloor, Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, null, mockGetViewFloor,
                        Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                        null, Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                        mockGetViewFloor, -0.00001f));
    }

    @Test
    public void testGetVisibilityAtOrigin() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var expectedCursorHits = 1;

        var result = rayCalculation.castRay(origin, origin.to2d());

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        testTileHit(origin.to2d(), 0, result);
    }

    @Test
    public void testGetVisibilityStraightHorizontalLineEast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightHorizontalLineWest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightVerticalLineSouth() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightVerticalLineNorth() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneSoutheast_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 5, 4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 1, 1),
                addOffsets2d(origin.to2d(), 2, 1),
                addOffsets2d(origin.to2d(), 2, 2),
                addOffsets2d(origin.to2d(), 3, 2),
                addOffsets2d(origin.to2d(), 3, 3),
                addOffsets2d(origin.to2d(), 4, 3),
                addOffsets2d(origin.to2d(), 4, 4),
                addOffsets2d(origin.to2d(), 5, 4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneSoutheast_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 8, 2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 2, 0),
                addOffsets2d(origin.to2d(), 2, 1),
                addOffsets2d(origin.to2d(), 3, 1),
                addOffsets2d(origin.to2d(), 4, 1),
                addOffsets2d(origin.to2d(), 5, 1),
                addOffsets2d(origin.to2d(), 6, 1),
                addOffsets2d(origin.to2d(), 6, 2),
                addOffsets2d(origin.to2d(), 7, 2),
                addOffsets2d(origin.to2d(), 8, 2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlope1Southeast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneSoutheast_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 4, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), 1, 1),
                addOffsets2d(origin.to2d(), 1, 2),
                addOffsets2d(origin.to2d(), 2, 2),
                addOffsets2d(origin.to2d(), 2, 3),
                addOffsets2d(origin.to2d(), 2, 4),
                addOffsets2d(origin.to2d(), 3, 4),
                addOffsets2d(origin.to2d(), 3, 5),
                addOffsets2d(origin.to2d(), 4, 5),
                addOffsets2d(origin.to2d(), 4, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneSoutheast_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 2, 7);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), 0, 2),
                addOffsets2d(origin.to2d(), 1, 2),
                addOffsets2d(origin.to2d(), 1, 3),
                addOffsets2d(origin.to2d(), 1, 4),
                addOffsets2d(origin.to2d(), 1, 5),
                addOffsets2d(origin.to2d(), 2, 5),
                addOffsets2d(origin.to2d(), 2, 6),
                addOffsets2d(origin.to2d(), 2, 7)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneNorthwest_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -5, -4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -1, -1),
                addOffsets2d(origin.to2d(), -2, -1),
                addOffsets2d(origin.to2d(), -2, -2),
                addOffsets2d(origin.to2d(), -3, -2),
                addOffsets2d(origin.to2d(), -3, -3),
                addOffsets2d(origin.to2d(), -4, -3),
                addOffsets2d(origin.to2d(), -4, -4),
                addOffsets2d(origin.to2d(), -5, -4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneNorthwest_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -8, -2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -2, 0),
                addOffsets2d(origin.to2d(), -2, -1),
                addOffsets2d(origin.to2d(), -3, -1),
                addOffsets2d(origin.to2d(), -4, -1),
                addOffsets2d(origin.to2d(), -5, -1),
                addOffsets2d(origin.to2d(), -6, -1),
                addOffsets2d(origin.to2d(), -6, -2),
                addOffsets2d(origin.to2d(), -7, -2),
                addOffsets2d(origin.to2d(), -8, -2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlope1Northwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneNorthwest_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -4, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), -1, -1),
                addOffsets2d(origin.to2d(), -1, -2),
                addOffsets2d(origin.to2d(), -2, -2),
                addOffsets2d(origin.to2d(), -2, -3),
                addOffsets2d(origin.to2d(), -2, -4),
                addOffsets2d(origin.to2d(), -3, -4),
                addOffsets2d(origin.to2d(), -3, -5),
                addOffsets2d(origin.to2d(), -4, -5),
                addOffsets2d(origin.to2d(), -4, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneNorthwest_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -2, -7);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 0, -2),
                addOffsets2d(origin.to2d(), -1, -2),
                addOffsets2d(origin.to2d(), -1, -3),
                addOffsets2d(origin.to2d(), -1, -4),
                addOffsets2d(origin.to2d(), -1, -5),
                addOffsets2d(origin.to2d(), -2, -5),
                addOffsets2d(origin.to2d(), -2, -6),
                addOffsets2d(origin.to2d(), -2, -7)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneNortheast_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 5, -4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 1, -1),
                addOffsets2d(origin.to2d(), 2, -1),
                addOffsets2d(origin.to2d(), 2, -2),
                addOffsets2d(origin.to2d(), 3, -2),
                addOffsets2d(origin.to2d(), 3, -3),
                addOffsets2d(origin.to2d(), 4, -3),
                addOffsets2d(origin.to2d(), 4, -4),
                addOffsets2d(origin.to2d(), 5, -4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneNortheast_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 8, -2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 2, 0),
                addOffsets2d(origin.to2d(), 2, -1),
                addOffsets2d(origin.to2d(), 3, -1),
                addOffsets2d(origin.to2d(), 4, -1),
                addOffsets2d(origin.to2d(), 5, -1),
                addOffsets2d(origin.to2d(), 6, -1),
                addOffsets2d(origin.to2d(), 6, -2),
                addOffsets2d(origin.to2d(), 7, -2),
                addOffsets2d(origin.to2d(), 8, -2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlope1Northeast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneNortheast_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 4, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 1, -1),
                addOffsets2d(origin.to2d(), 1, -2),
                addOffsets2d(origin.to2d(), 2, -2),
                addOffsets2d(origin.to2d(), 2, -3),
                addOffsets2d(origin.to2d(), 2, -4),
                addOffsets2d(origin.to2d(), 3, -4),
                addOffsets2d(origin.to2d(), 3, -5),
                addOffsets2d(origin.to2d(), 4, -5),
                addOffsets2d(origin.to2d(), 4, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneNortheast_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 2, -7);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 0, -2),
                addOffsets2d(origin.to2d(), 1, -2),
                addOffsets2d(origin.to2d(), 1, -3),
                addOffsets2d(origin.to2d(), 1, -4),
                addOffsets2d(origin.to2d(), 1, -5),
                addOffsets2d(origin.to2d(), 2, -5),
                addOffsets2d(origin.to2d(), 2, -6),
                addOffsets2d(origin.to2d(), 2, -7)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneSouthwest_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -5, 4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -1, 1),
                addOffsets2d(origin.to2d(), -2, 1),
                addOffsets2d(origin.to2d(), -2, 2),
                addOffsets2d(origin.to2d(), -3, 2),
                addOffsets2d(origin.to2d(), -3, 3),
                addOffsets2d(origin.to2d(), -4, 3),
                addOffsets2d(origin.to2d(), -4, 4),
                addOffsets2d(origin.to2d(), -5, 4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneSouthwest_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -8, 2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -2, 0),
                addOffsets2d(origin.to2d(), -2, 1),
                addOffsets2d(origin.to2d(), -3, 1),
                addOffsets2d(origin.to2d(), -4, 1),
                addOffsets2d(origin.to2d(), -5, 1),
                addOffsets2d(origin.to2d(), -6, 1),
                addOffsets2d(origin.to2d(), -6, 2),
                addOffsets2d(origin.to2d(), -7, 2),
                addOffsets2d(origin.to2d(), -8, 2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlope1Southwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneSouthwest_1() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -4, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), -1, 1),
                addOffsets2d(origin.to2d(), -1, 2),
                addOffsets2d(origin.to2d(), -2, 2),
                addOffsets2d(origin.to2d(), -2, 3),
                addOffsets2d(origin.to2d(), -2, 4),
                addOffsets2d(origin.to2d(), -3, 4),
                addOffsets2d(origin.to2d(), -3, 5),
                addOffsets2d(origin.to2d(), -4, 5),
                addOffsets2d(origin.to2d(), -4, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneSouthwest_2() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -2, -7);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 0, -2),
                addOffsets2d(origin.to2d(), -1, -2),
                addOffsets2d(origin.to2d(), -1, -3),
                addOffsets2d(origin.to2d(), -1, -4),
                addOffsets2d(origin.to2d(), -1, -5),
                addOffsets2d(origin.to2d(), -2, -5),
                addOffsets2d(origin.to2d(), -2, -6),
                addOffsets2d(origin.to2d(), -2, -7)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    // 'blockingSegmentDist' implies the number of tiles _away from_ the origin, e.g. a value of
    // 0 implies it's adjacent

    @Test
    public void testVisibilityBlockingSegmentStraightLineEast() {
        movingEast = true;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(VERTICAL,
                addOffsets3d(origin, blockingSegmentDist + 1, 0, 0), true);
        segmentReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineWest() {
        movingEast = false;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(VERTICAL,
                addOffsets3d(origin, -blockingSegmentDist, 0, 0), true);
        segmentReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineSouth() {
        movingEast = false;
        movingSouth = true;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(HORIZONTAL,
                addOffsets3d(origin, 0, blockingSegmentDist + 1, 0), true);
        segmentReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y + i), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineNorth() {
        movingEast = false;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(HORIZONTAL,
                addOffsets3d(origin, 0, -blockingSegmentDist, 0), true);
        segmentReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits, totalSegmentsInResult(result));
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y - i), i, result);
        }
    }

    @Test
    public void testCannotSeeTileBeneathSufficientlyDeepCliff() {
        movingEast = true;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 1, 0);
        reset(mockGameZone);
        var heightZ = randomIntInRange(1, 8);

        Map<Coordinate3d, WallSegment> cliffSegs = mapOf();
        for (var i = 0; i < heightZ; i++) {
            var segLoc = addOffsets3d(origin, 1, 0, -i - 1);
            cliffSegs.put(segLoc, makeMockSegment(VERTICAL, segLoc, true));
        }
        when(mockGameZone.getSegments(any()))
                .thenReturn(mapOf(
                        pairOf(HORIZONTAL, mapOf()),
                        pairOf(CORNER, mapOf()),
                        pairOf(VERTICAL, cliffSegs)
                ));

        var mockTiles1 = setOf(makeMockTile(origin, false));
        var mockTiles2 = setOf(makeMockTile(addOffsets3d(origin, 1, 0, -heightZ), false));
        when(mockGameZone.tiles(any()))
                .thenReturn(mockTiles1)
                .thenReturn(mockTiles2);

        var result = rayCalculation.castRay(origin, destination);

        assertEquals(2, result.tiles().size());
        assertEquals(heightZ, totalSegmentsInResult(result));
    }

    @Test
    public void testBlockingTileBlocksVisibilityDirectlyBeneathItself() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var mockSegmentLoc2d = randomCoordinate3dInNormalRangeAtZ().to2d();
        var mockSegmentLoc = mockSegmentLoc2d.to3d(randomIntWithInclusiveCeiling(Z - 1));
        var mockSegment = makeMockSegment(VERTICAL, randomCoordinate3dInNormalRangeAtZ(), false);
        reset(mockGameZone);
        when(mockGameZone.getSegments(any())).thenReturn(mapOf(
                pairOf(HORIZONTAL, mapOf()),
                pairOf(CORNER, mapOf()),
                pairOf(VERTICAL, mapOf(pairOf(mockSegmentLoc, mockSegment)))
        ));
        var mockTileFloor = makeMockTile(origin, true);
        var mockTileBeneathFloor = makeMockTile(addOffsets3d(origin, 0, 0, -1), false);
        when(mockGameZone.tiles(any())).thenReturn(setOf(mockTileFloor, mockTileBeneathFloor));

        var result = rayCalculation.castRay(origin, origin.to2d());

        assertEquals(1, result.tiles().size());
        assertEquals(0, totalSegmentsInResult(result));
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItself() {
        // This will also serve as an indirect test to see whether blocking slope ranges
        // 'condense', since the visibility line to the Tile which should be blocked would
        // otherwise slip through the blocking 'shadows' of both the tile and the segment.
    }

    @Test
    public void testBlockingTileBlocksVisibilityAboveItself() {
        // Including segments
    }

    @Test
    public void testViewCeilingBlocksVisibility() {

    }

    @Test
    public void testViewFloorBlocksVisibility() {

    }

    private void testTileHit(Coordinate2d expectedTarget, int index, Result result) {
        verify(mockGameZone).tiles(expectedTarget);
        assertTrue(result.tiles().keySet().stream()
                .anyMatch(loc -> loc.to2d().equals(expectedTarget)));
        assertEquals(expectedTarget, tilesReturned.get(index).item1().to2d());

        verify(mockGameZone).getSegments(expectedTarget);
        var expectedOrientation = segmentsReturned.get(index).getValue0();
        var expectedSegReturned = segmentsReturned.get(index).getValue2();
        assertEquals(segmentsReturned.get(index).getValue1(), expectedSegReturned.location());
        assertTrue(result.segments().get(expectedOrientation)
                .containsValue(segmentsReturned.get(index).getValue2()));
        var expectedSegLoc =
                addOffsets2d(expectedTarget, (movingEast ? 1 : 0), (movingSouth ? 1 : 0));
        assertEquals(expectedSegLoc, expectedSegReturned.location().to2d());
    }

    private int totalSegmentsInResult(Result result) {
        return result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                result.segments().get(VERTICAL).size();
    }

    private Tile makeMockTile(Coordinate3d loc, boolean blocking) {
        var mockTile = mock(Tile.class);
        when(mockTile.location()).thenReturn(loc);
        if (blocking) {
            when(mockTile.getGroundType()).thenReturn(mockGroundTypeBlocking);
        }
        else {
            when(mockTile.getGroundType()).thenReturn(mockGroundTypeTransparent);
        }
        tilesReturned.add(pairOf(loc, mockTile));
        return mockTile;
    }

    private WallSegment makeMockSegment(WallSegmentOrientation orientation, Coordinate3d loc,
                                        boolean blocking) {
        var mockSegmentType = mock(WallSegmentType.class);
        when(mockSegmentType.orientation()).thenReturn(orientation);
        when(mockSegmentType.blocksSight()).thenReturn(blocking);
        var mockSegment = mock(WallSegment.class);
        when(mockSegment.getType()).thenReturn(mockSegmentType);
        when(mockSegment.location()).thenReturn(loc);
        return mockSegment;
    }

    // NB: With excessively high or low values, the floating point calculations used to calculate
    // the tiles covered by a visibility ray no longer work properly, due to floating point
    // rounding issues. This isn't an issue in practice, since no GameZone should need more than
    // 100,000,000 tiles, so this range should be adequate for testing.
    private Coordinate3d randomCoordinate3dInNormalRangeAtZ() {
        return Coordinate3d.of(
                randomIntInRange(-10000, 10000),
                randomIntInRange(-10000, 10000),
                Z
        );
    }

    @Test
    public void testGetInterfaceName() {
        assertEquals(TileVisibilityRayCalculation.class.getCanonicalName(),
                rayCalculation.getInterfaceName());
    }
}
