package inaugural.soliloquy.ruleset.gameconcepts;

import org.javatuples.Triplet;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import soliloquy.specs.common.valueobjects.Coordinate2d;
import soliloquy.specs.common.valueobjects.Coordinate3d;
import soliloquy.specs.common.valueobjects.Pair;
import soliloquy.specs.gamestate.entities.GameZone;
import soliloquy.specs.gamestate.entities.Tile;
import soliloquy.specs.gamestate.entities.WallSegment;
import soliloquy.specs.gamestate.entities.WallSegmentOrientation;
import soliloquy.specs.ruleset.entities.GroundType;
import soliloquy.specs.ruleset.entities.WallSegmentType;
import soliloquy.specs.ruleset.gameconcepts.TileVisibilityRayCalculation;

import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Supplier;

import static inaugural.soliloquy.tools.collections.Collections.*;
import static inaugural.soliloquy.tools.random.Random.*;
import static inaugural.soliloquy.tools.valueobjects.Coordinate2d.addOffsets2d;
import static inaugural.soliloquy.tools.valueobjects.Coordinate3d.addOffsets3d;
import static inaugural.soliloquy.tools.valueobjects.Pair.pairOf;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static soliloquy.specs.gamestate.entities.WallSegmentOrientation.*;
import static soliloquy.specs.ruleset.gameconcepts.TileVisibilityCalculation.Result;

// Coordinates used for testing tiles to run over were generated by creating a line in a graphing
// calculator which intersects the offset of the target from the origin. Each tile's location can
// be treated as the intersections between whole-number values on the axes, with the segments at
// the +/-0.5 boundaries. When the line intersecting the target offset tile's location crosses a
// 0.5 boundary, again representing crossing a segment plane from one 2d coordinate to another,
// that is treated as a testing requirement for the visibility ray's cursor to move to that 2d
// location from its previous location.
@ExtendWith(MockitoExtension.class)
public class TileVisibilityRayCalculationImplTests {

    // Z values must be within a reasonable value, to avoid bizarre rounding errors
    private final int Z = 0;//randomIntInRange(-10000, 10000);
    private final float Z_ADDEND_BELOW = 10;

    @Mock private Supplier<GameZone> mockGetGameZone;
    @Mock private Function<Coordinate3d, Integer> mockGetViewCeiling;
    @Mock private Function<Coordinate3d, Integer> mockGetViewFloor;
    @Mock private GameZone mockGameZone;
    @Mock private GroundType mockGroundTypeTransparent;
    @Mock private GroundType mockGroundTypeBlocking;

    private List<Pair<Coordinate3d, Tile>> tilesReturned;
    private Map<Integer, Tile> tileGameZoneReturnOverrides;
    private int tileGenCounter;
    private List<Triplet<WallSegmentOrientation, Coordinate3d, WallSegment>> segmentsReturned;
    private Map<Integer, WallSegment> segmentGameZoneReturnOverrides;
    private int segmentGenCounter;
    // NB: These are only relevant in line-of-sight blocking tests, since segments will need to
    // be at specific locations to not potentially overlap
    private boolean movingEast;
    private boolean movingSouth;

    private TileVisibilityRayCalculation rayCalculation;

    @BeforeEach
    public void setUp() {
        tilesReturned = listOf();
        tileGameZoneReturnOverrides = mapOf();
        tileGenCounter = 0;
        segmentsReturned = listOf();
        segmentGameZoneReturnOverrides = mapOf();
        segmentGenCounter = 0;
        movingEast = movingSouth = false;

        lenient().when(mockGameZone.segments(any())).thenAnswer(invocation -> {
            var index = segmentGenCounter++;
            WallSegment mockSegment;
            if (segmentGameZoneReturnOverrides.containsKey(index)) {
                mockSegment = segmentGameZoneReturnOverrides.get(index);
            }
            else {
                var orientation = WallSegmentOrientation.fromValue(randomIntInRange(1, 3));
                Coordinate2d segLoc = invocation.getArgument(0);
                var segLocX = segLoc.X + (movingEast ? 1 : 0);
                var segLocY = segLoc.Y + (movingSouth ? 1 : 0);
                mockSegment =
                        makeMockSegment(orientation, Coordinate3d.of(segLocX, segLocY, Z), false);
            }
            var orientation = mockSegment.getType().orientation();
            var loc = mockSegment.location();
            segmentsReturned.add(Triplet.with(orientation, loc, mockSegment));
            return populatedMap(mockSegment);
        });
        lenient().when(mockGameZone.tiles(any())).thenAnswer(invocation -> {
            var index = tileGenCounter++;
            Tile mockTile;
            if (tileGameZoneReturnOverrides.containsKey(index)) {
                mockTile = tileGameZoneReturnOverrides.get(index);
            }
            else {
                mockTile = makeMockTile(((Coordinate2d) invocation.getArgument(0)).to3d(Z), false);
            }
            return setOf(mockTile);
        });
        lenient().when(mockGetGameZone.get()).thenReturn(mockGameZone);

        lenient().when(mockGroundTypeBlocking.blocksSight()).thenReturn(true);
        lenient().when(mockGroundTypeTransparent.blocksSight()).thenReturn(false);

        rayCalculation = new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                mockGetViewFloor, Z_ADDEND_BELOW);
    }

    @Test
    public void testConstructorWithInvalidArgs() {
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(null, mockGetViewCeiling,
                        mockGetViewFloor, Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, null, mockGetViewFloor,
                        Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                        null, Z_ADDEND_BELOW));
        assertThrows(IllegalArgumentException.class,
                () -> new TileVisibilityRayCalculationImpl(mockGetGameZone, mockGetViewCeiling,
                        mockGetViewFloor, -0.00001f));
    }

    @Test
    public void testGetVisibilityAtOrigin() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var expectedCursorHits = 1;

        var result = rayCalculation.castRay(origin, origin.to2d());

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        testTileHit(origin.to2d(), 0, result);
    }

    @Test
    public void testGetVisibilityStraightHorizontalLineEast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightHorizontalLineWest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightVerticalLineSouth() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityStraightVerticalLineNorth() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneSoutheast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 5, 4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 1, 1),
                addOffsets2d(origin.to2d(), 2, 1),
                addOffsets2d(origin.to2d(), 2, 2),
                addOffsets2d(origin.to2d(), 3, 2),
                addOffsets2d(origin.to2d(), 3, 3),
                addOffsets2d(origin.to2d(), 4, 3),
                addOffsets2d(origin.to2d(), 4, 4),
                addOffsets2d(origin.to2d(), 5, 4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneSoutheastIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 6, 2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 2, 1),
                addOffsets2d(origin.to2d(), 3, 1),
                addOffsets2d(origin.to2d(), 4, 1),
                addOffsets2d(origin.to2d(), 5, 2),
                addOffsets2d(origin.to2d(), 6, 2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlope1Southeast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneSoutheast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 4, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), 1, 1),
                addOffsets2d(origin.to2d(), 1, 2),
                addOffsets2d(origin.to2d(), 2, 2),
                addOffsets2d(origin.to2d(), 2, 3),
                addOffsets2d(origin.to2d(), 2, 4),
                addOffsets2d(origin.to2d(), 3, 4),
                addOffsets2d(origin.to2d(), 3, 5),
                addOffsets2d(origin.to2d(), 4, 5),
                addOffsets2d(origin.to2d(), 4, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneSoutheastIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 2, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), 1, 2),
                addOffsets2d(origin.to2d(), 1, 3),
                addOffsets2d(origin.to2d(), 1, 4),
                addOffsets2d(origin.to2d(), 2, 5),
                addOffsets2d(origin.to2d(), 2, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneNorthwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -5, -4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -1, -1),
                addOffsets2d(origin.to2d(), -2, -1),
                addOffsets2d(origin.to2d(), -2, -2),
                addOffsets2d(origin.to2d(), -3, -2),
                addOffsets2d(origin.to2d(), -3, -3),
                addOffsets2d(origin.to2d(), -4, -3),
                addOffsets2d(origin.to2d(), -4, -4),
                addOffsets2d(origin.to2d(), -5, -4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeBelowOneNorthwestIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -6, -2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -2, -1),
                addOffsets2d(origin.to2d(), -3, -1),
                addOffsets2d(origin.to2d(), -4, -1),
                addOffsets2d(origin.to2d(), -5, -2),
                addOffsets2d(origin.to2d(), -6, -2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlope1Northwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneNorthwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -4, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), -1, -1),
                addOffsets2d(origin.to2d(), -1, -2),
                addOffsets2d(origin.to2d(), -2, -2),
                addOffsets2d(origin.to2d(), -2, -3),
                addOffsets2d(origin.to2d(), -2, -4),
                addOffsets2d(origin.to2d(), -3, -4),
                addOffsets2d(origin.to2d(), -3, -5),
                addOffsets2d(origin.to2d(), -4, -5),
                addOffsets2d(origin.to2d(), -4, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAnglePosSlopeAboveOneNorthwestIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -2, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), -1, -2),
                addOffsets2d(origin.to2d(), -1, -3),
                addOffsets2d(origin.to2d(), -1, -4),
                addOffsets2d(origin.to2d(), -2, -5),
                addOffsets2d(origin.to2d(), -2, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneNortheast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 5, -4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 1, -1),
                addOffsets2d(origin.to2d(), 2, -1),
                addOffsets2d(origin.to2d(), 2, -2),
                addOffsets2d(origin.to2d(), 3, -2),
                addOffsets2d(origin.to2d(), 3, -3),
                addOffsets2d(origin.to2d(), 4, -3),
                addOffsets2d(origin.to2d(), 4, -4),
                addOffsets2d(origin.to2d(), 5, -4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneNortheastIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 6, -2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 1, 0),
                addOffsets2d(origin.to2d(), 2, -1),
                addOffsets2d(origin.to2d(), 3, -1),
                addOffsets2d(origin.to2d(), 4, -1),
                addOffsets2d(origin.to2d(), 5, -2),
                addOffsets2d(origin.to2d(), 6, -2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlope1Northeast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y - i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneNortheast() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 4, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 1, -1),
                addOffsets2d(origin.to2d(), 1, -2),
                addOffsets2d(origin.to2d(), 2, -2),
                addOffsets2d(origin.to2d(), 2, -3),
                addOffsets2d(origin.to2d(), 2, -4),
                addOffsets2d(origin.to2d(), 3, -4),
                addOffsets2d(origin.to2d(), 3, -5),
                addOffsets2d(origin.to2d(), 4, -5),
                addOffsets2d(origin.to2d(), 4, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneNortheastIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 2, -6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, -1),
                addOffsets2d(origin.to2d(), 1, -2),
                addOffsets2d(origin.to2d(), 1, -3),
                addOffsets2d(origin.to2d(), 1, -4),
                addOffsets2d(origin.to2d(), 2, -5),
                addOffsets2d(origin.to2d(), 2, -6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneSouthwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -5, 4);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -1, 1),
                addOffsets2d(origin.to2d(), -2, 1),
                addOffsets2d(origin.to2d(), -2, 2),
                addOffsets2d(origin.to2d(), -3, 2),
                addOffsets2d(origin.to2d(), -3, 3),
                addOffsets2d(origin.to2d(), -4, 3),
                addOffsets2d(origin.to2d(), -4, 4),
                addOffsets2d(origin.to2d(), -5, 4)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeBelowOneSouthwestIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -6, 2);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), -1, 0),
                addOffsets2d(origin.to2d(), -2, 1),
                addOffsets2d(origin.to2d(), -3, 1),
                addOffsets2d(origin.to2d(), -4, 1),
                addOffsets2d(origin.to2d(), -5, 2),
                addOffsets2d(origin.to2d(), -6, 2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlope1Southwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(2, 10);
        var expectedCursorHits = rayLength + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(expectedCursorHits, segmentsReturned.size());
        for (var i = 0; i <= rayLength; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y + i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneSouthwest() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -4, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), -1, 1),
                addOffsets2d(origin.to2d(), -1, 2),
                addOffsets2d(origin.to2d(), -2, 2),
                addOffsets2d(origin.to2d(), -2, 3),
                addOffsets2d(origin.to2d(), -2, 4),
                addOffsets2d(origin.to2d(), -3, 4),
                addOffsets2d(origin.to2d(), -3, 5),
                addOffsets2d(origin.to2d(), -4, 5),
                addOffsets2d(origin.to2d(), -4, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testGetVisibilityAtAngleNegSlopeAboveOneSouthwestIntersectingCornerVertices() {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), -2, 6);

        var result = rayCalculation.castRay(origin, destination);

        var expectedTiles = listOf(
                addOffsets2d(origin.to2d(), 0, 0),
                addOffsets2d(origin.to2d(), 0, 1),
                addOffsets2d(origin.to2d(), -1, 2),
                addOffsets2d(origin.to2d(), -1, 3),
                addOffsets2d(origin.to2d(), -1, 4),
                addOffsets2d(origin.to2d(), -2, 5),
                addOffsets2d(origin.to2d(), -2, 6)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        assertEquals(expectedTiles.size(), segmentsReturned.size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    // 'blockingSegmentDist' implies the number of tiles _away from_ the origin, e.g. a value of
    // 0 implies it's adjacent

    @Test
    public void testVisibilityBlockingSegmentStraightLineEast() {
        movingEast = true;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(VERTICAL,
                addOffsets3d(origin, blockingSegmentDist + 1, 0, 0), true);
        segmentGameZoneReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X + rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X + i, origin.Y), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineWest() {
        movingEast = false;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(VERTICAL,
                addOffsets3d(origin, -blockingSegmentDist, 0, 0), true);
        segmentGameZoneReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X - rayLength, origin.Y);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X - i, origin.Y), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineSouth() {
        movingEast = false;
        movingSouth = true;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(HORIZONTAL,
                addOffsets3d(origin, 0, blockingSegmentDist + 1, 0), true);
        segmentGameZoneReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y + rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits,
                result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                        result.segments().get(VERTICAL).size());
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y + i), i, result);
        }
    }

    @Test
    public void testVisibilityBlockingSegmentStraightLineNorth() {
        movingEast = false;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var rayLength = randomIntInRange(7, 10);
        var blockingSegmentDist = randomIntInRange(2, 4);
        var mockBlockingSegment = makeMockSegment(HORIZONTAL,
                addOffsets3d(origin, 0, -blockingSegmentDist, 0), true);
        segmentGameZoneReturnOverrides.put(blockingSegmentDist, mockBlockingSegment);
        var expectedCursorHits = blockingSegmentDist + 1;
        var destination = Coordinate2d.of(origin.X, origin.Y - rayLength);

        var result = rayCalculation.castRay(origin, destination);

        assertNotNull(result);
        assertEquals(expectedCursorHits, result.tiles().size());
        assertEquals(3, result.segments().size());
        assertEquals(expectedCursorHits, totalSegmentsInResult(result));
        for (var i = 0; i < expectedCursorHits; i++) {
            testTileHit(Coordinate2d.of(origin.X, origin.Y - i), i, result);
        }
    }

    @Test
    public void testCannotSeeTileBeneathSufficientlyDeepCliff() {
        movingEast = true;
        movingSouth = false;
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var destination = addOffsets2d(origin.to2d(), 1, 0);
        reset(mockGameZone);
        var heightZ = randomIntInRange(1, 8);

        Map<Coordinate3d, WallSegment> cliffSegs = mapOf();
        for (var i = 0; i < heightZ; i++) {
            var segLoc = addOffsets3d(origin, 1, 0, -i - 1);
            cliffSegs.put(segLoc, makeMockSegment(VERTICAL, segLoc, true));
        }
        when(mockGameZone.segments(any()))
                .thenReturn(mapOf(
                        pairOf(HORIZONTAL, mapOf()),
                        pairOf(CORNER, mapOf()),
                        pairOf(VERTICAL, cliffSegs)
                ));

        var mockTiles1 = setOf(makeMockTile(origin, false));
        var mockTiles2 = setOf(makeMockTile(addOffsets3d(origin, 1, 0, -heightZ), false));
        when(mockGameZone.tiles(any()))
                .thenReturn(mockTiles1)
                .thenReturn(mockTiles2);

        var result = rayCalculation.castRay(origin, destination);

        assertEquals(2, result.tiles().size());
        assertEquals(heightZ, totalSegmentsInResult(result));
    }

    @Test
    public void testBlockingTileBlocksVisibilityDirectlyBeneathItself() {
        var mockBlockedAtOriginZ = randomIntWithInclusiveCeiling(Z - 1);
        var blockedEntitiesDepth = -(int) Math.ceil(Z_ADDEND_BELOW + 2);

        runBlockingTileBlocksVisibilityTest(true, mockBlockedAtOriginZ, randomBoolean(),
                blockedEntitiesDepth);
    }

    @Test
    public void testBlockingTileBlocksVisibilityAboveItself() {
        // Keeping a restrained range to be sure we're avoiding rounding errors
        var ceilingHeightOffset = randomIntInRange(1, 5);
        var blockedEntitiesZOffset = ceilingHeightOffset + 10;

        runBlockingTileBlocksVisibilityTest(randomBoolean(), ceilingHeightOffset, true,
                blockedEntitiesZOffset);
    }

    @Test
    public void testViewCeilingBlocksVisibility() {
        var ceilingHeightOffset = randomIntInRange(1, 5);
        var blockedEntitiesZOffset = ceilingHeightOffset + 10;
        when(mockGetViewCeiling.apply(any())).thenReturn(Z + ceilingHeightOffset);

        var origin = runBlockingTileBlocksVisibilityTest(false, ceilingHeightOffset, false,
                blockedEntitiesZOffset);

        verify(mockGetViewCeiling).apply(eq(origin));
        verify(mockGetViewCeiling).apply(eq(addOffsets3d(origin, 1, 0, 0)));
    }

    @Test
    public void testViewFloorBlocksVisibility() {
        var mockBlockedAtOriginZ = randomIntWithInclusiveCeiling(Z - 1);
        var blockedEntitiesDepth = -(int) Math.ceil(Z_ADDEND_BELOW + 2);
        when(mockGetViewFloor.apply(any())).thenReturn(Z);

        var origin = runBlockingTileBlocksVisibilityTest(false, mockBlockedAtOriginZ, false,
                blockedEntitiesDepth);

        verify(mockGetViewFloor).apply(eq(origin));
        verify(mockGetViewFloor).apply(eq(addOffsets3d(origin, 1, 0, 0)));
    }

    private Coordinate3d runBlockingTileBlocksVisibilityTest(boolean originTileBlocks,
                                                             int mockAtOriginZOffset,
                                                             boolean mockAtOriginWithOffsetBlocks,
                                                             int blockedAdjacentEntitiesZOffset) {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var atOriginWithZOffsetLoc = addOffsets3d(origin, 0, 0, mockAtOriginZOffset);
        var mockSegmentsAtOriginWithOffset =
                populatedMap(makeMockSegment(VERTICAL, atOriginWithZOffsetLoc, false));
        var mockBlockedAdjacentLoc =
                Coordinate3d.of(origin.X + 1, origin.Y, origin.Z + blockedAdjacentEntitiesZOffset);
        var mockAdjacentSegments =
                populatedMap(makeMockSegment(VERTICAL, mockBlockedAdjacentLoc, false));
        reset(mockGameZone);
        when(mockGameZone.segments(any()))
                .thenReturn(mockSegmentsAtOriginWithOffset)
                .thenReturn(mockAdjacentSegments);
        var mockTileAtOrigin = makeMockTile(origin, originTileBlocks);
        var mockTileAtOriginWithOffset =
                makeMockTile(atOriginWithZOffsetLoc, mockAtOriginWithOffsetBlocks);
        var mockAdjBlockedTile =
                makeMockTile(addOffsets3d(origin, 1, 0, blockedAdjacentEntitiesZOffset), false);
        when(mockGameZone.tiles(any()))
                .thenReturn(setOf(mockTileAtOrigin, mockTileAtOriginWithOffset))
                .thenReturn(setOf(mockAdjBlockedTile));

        var result = rayCalculation.castRay(origin, addOffsets2d(origin.to2d(), 1, 0));

        assertEquals(1, result.tiles().size());
        assertEquals(0, totalSegmentsInResult(result));

        return origin;
    }

    // These will also serve as an indirect test to see whether blocking slope ranges 'condense',
    // since the visibility line to the Tile which should be blocked would otherwise slip through
    // the blocking 'shadows' of both the tile and the segment.

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfEast() {
        runTileBlockingTest(VERTICAL, 1, 0, 1, 0, 2, 0);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfNortheast() {
        runTileBlockingTest(CORNER, 1, 0, 1, -1, 2, -1);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfNorth() {
        runTileBlockingTest(HORIZONTAL, 0, 0, 0, -1, 0, -2);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfNorthwest() {
        runTileBlockingTest(CORNER, 0, 0, -1, -1, -1, -1);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfWest() {
        runTileBlockingTest(VERTICAL, 0, 0, -1, 0, -1, 0);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfSouthwest() {
        runTileBlockingTest(CORNER, 0, 1, -1, 1, -1, 2);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfSouth() {
        runTileBlockingTest(HORIZONTAL, 0, 1, 0, 1, 0, 2);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfSoutheast() {
        runTileBlockingTest(CORNER, 1, 1, 1, 1, 2, 2);
    }

    @Test
    public void testBlockingTileCastsShadowBlockingVisibilityBeneathItselfNortheastNoncardinal() {
        var elevatedZ = Z + 50;
        var elevatedOrigin = Coordinate3d.of(0, 0, elevatedZ);//randomCoordinate3dInNormalRangeAtZ().to2d().to3d(Z + 50);
        var mockBlockingTiles = new Tile[5];
        mockBlockingTiles[0] = makeMockTile(addOffsets3d(elevatedOrigin, 0, 0, 0), true);
        mockBlockingTiles[1] = makeMockTile(addOffsets3d(elevatedOrigin, 1, 0, 0), true);
        mockBlockingTiles[2] = makeMockTile(addOffsets3d(elevatedOrigin, 1, 1, 0), true);
        mockBlockingTiles[3] = makeMockTile(addOffsets3d(elevatedOrigin, 2, 1, 0), true);
        mockBlockingTiles[4] = makeMockTile(addOffsets3d(elevatedOrigin, 2, 2, 0), true);
        for (var i = 0; i < mockBlockingTiles.length; i++) {
            tileGameZoneReturnOverrides.put(i, mockBlockingTiles[i]);
        }
        var mockBlockingSegments = new WallSegment[5];
        mockBlockingSegments[0] = makeMockSegment(CORNER, addOffsets3d(elevatedOrigin, 0, 0, 0), false);
        mockBlockingSegments[1] = makeMockSegment(CORNER, addOffsets3d(elevatedOrigin, 1, 0, 0), false);
        mockBlockingSegments[2] = makeMockSegment(CORNER, addOffsets3d(elevatedOrigin, 1, 1, 0), false);
        mockBlockingSegments[3] = makeMockSegment(CORNER, addOffsets3d(elevatedOrigin, 2, 1, 0), false);
        mockBlockingSegments[4] = makeMockSegment(CORNER, addOffsets3d(elevatedOrigin, 2, 2, 0), false);
        for (var i = 0; i < mockBlockingTiles.length; i++) {
            segmentGameZoneReturnOverrides.put(i, mockBlockingSegments[i]);
        }
        var destination = addOffsets2d(elevatedOrigin.to2d(), 5, 4);

        var result = rayCalculation.castRay(elevatedOrigin, destination);

        var expectedTiles = listOf(
                addOffsets2d(elevatedOrigin.to2d(), 0, 0),
                addOffsets2d(elevatedOrigin.to2d(), 1, 0),
                addOffsets2d(elevatedOrigin.to2d(), 1, 1),
                addOffsets2d(elevatedOrigin.to2d(), 2, 1),
                addOffsets2d(elevatedOrigin.to2d(), 2, 2)
        );
        assertNotNull(result);
        assertEquals(expectedTiles.size(), result.tiles().size());
        for (var i = 0; i < expectedTiles.size(); i++) {
            testTileHit(expectedTiles.get(i), i, result);
        }
    }

    @Test
    public void testRayStopsWhenCompletelyBlocked() {
        reset(mockGameZone);
        when(mockGetViewFloor.apply(any())).thenReturn(Z);
        when(mockGetViewCeiling.apply(any())).thenReturn(Z + 1);
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var mockSegment = makeMockSegment(VERTICAL, addOffsets3d(origin, 1, 0, 0), true);
        var mockSegments = populatedMap(mockSegment);
        when(mockGameZone.segments(any())).thenReturn(mockSegments);
        when(mockGameZone.tiles(any())).thenReturn(setOf());

        rayCalculation.castRay(origin, Coordinate2d.of(origin.X + 1, origin.Y));

        verify(mockGameZone, times(1)).tiles(any());
    }

    private void runTileBlockingTest(WallSegmentOrientation orientation,
                                     int blockingSegOffsetX, int blockingSegOffsetY,
                                     int blockedTilesOffsetX, int blockedTilesOffsetY,
                                     int blockedSegsOffsetX, int blockedSegsOffsetY) {
        var origin = randomCoordinate3dInNormalRangeAtZ();
        var mockBlockingSegment = makeMockSegment(orientation,
                addOffsets3d(origin, blockingSegOffsetX, blockingSegOffsetY, 0), true);
        var mockBlockingTile = makeMockTile(origin, true);
        // This range of blocking to test ensures that the angles beneath the blocking tile, to
        // the side of the blocking segment, and between them are all blocked
        var blockedLocsToTest = (int) Z_ADDEND_BELOW + 3;
        var mockBlockedTiles = new Tile[blockedLocsToTest];
        var mockBlockedSegments = new WallSegment[blockedLocsToTest];
        for (var i = 0; i < blockedLocsToTest; i++) {
            var mockTile =
                    makeMockTile(addOffsets3d(origin, blockedTilesOffsetX, blockedTilesOffsetY, -i),
                            false);
            var mockSegment = makeMockSegment(orientation,
                    addOffsets3d(origin, blockedSegsOffsetX, blockedSegsOffsetY, -i), false);
            mockBlockedTiles[i] = mockTile;
            mockBlockedSegments[i] = mockSegment;
        }
        reset(mockGameZone);
        when(mockGameZone.tiles(any()))
                .thenReturn(setOf(mockBlockingTile))
                .thenReturn(setOf(mockBlockedTiles))
                .thenReturn(setOf());
        var mockBlockingSegmentsMap = populatedMap(mockBlockingSegment);
        var mockBlockedSegmentsMap = populatedMap(mockBlockedSegments);
        when(mockGameZone.segments(any()))
                .thenReturn(mockBlockingSegmentsMap)
                .thenReturn(mockBlockedSegmentsMap)
                .thenReturn(populatedMap());

        var result = rayCalculation.castRay(origin,
                addOffsets2d(origin.to2d(), blockedTilesOffsetX, blockedTilesOffsetY));

        assertEquals(1, result.tiles().size());
        //noinspection OptionalGetWithoutIsPresent
        assertEquals(origin,
                result.tiles().entrySet().stream().findFirst().get().getValue().location());
        assertEquals(1, totalSegmentsInResult(result));
    }

    private void testTileHit(Coordinate2d expectedTarget, int index, Result result) {
        verify(mockGameZone).tiles(expectedTarget);
        assertTrue(result.tiles().keySet().stream()
                .anyMatch(loc -> loc.to2d().equals(expectedTarget)));
        assertEquals(expectedTarget, tilesReturned.get(index).item1().to2d());

        verify(mockGameZone).segments(expectedTarget);
        var expectedOrientation = segmentsReturned.get(index).getValue0();
        var expectedSegReturned = segmentsReturned.get(index).getValue2();
        assertEquals(segmentsReturned.get(index).getValue1(), expectedSegReturned.location());
        assertTrue(result.segments().get(expectedOrientation)
                .containsValue(segmentsReturned.get(index).getValue2()));
        var expectedSegLoc =
                addOffsets2d(expectedTarget, (movingEast ? 1 : 0), (movingSouth ? 1 : 0));
        assertEquals(expectedSegLoc, expectedSegReturned.location().to2d());
    }

    private int totalSegmentsInResult(Result result) {
        return result.segments().get(HORIZONTAL).size() + result.segments().get(CORNER).size() +
                result.segments().get(VERTICAL).size();
    }

    private Tile makeMockTile(Coordinate3d loc, boolean blocking) {
        var mockTile = mock(Tile.class);
        when(mockTile.location()).thenReturn(loc);
        if (blocking) {
            when(mockTile.getGroundType()).thenReturn(mockGroundTypeBlocking);
        }
        else {
            when(mockTile.getGroundType()).thenReturn(mockGroundTypeTransparent);
        }
        tilesReturned.add(pairOf(loc, mockTile));
        return mockTile;
    }

    private WallSegment makeMockSegment(WallSegmentOrientation orientation, Coordinate3d loc,
                                        boolean blocking) {
        var mockSegmentType = mock(WallSegmentType.class);
        lenient().when(mockSegmentType.orientation()).thenReturn(orientation);
        lenient().when(mockSegmentType.blocksSight()).thenReturn(blocking);
        var mockSegment = mock(WallSegment.class);
        lenient().when(mockSegment.getType()).thenReturn(mockSegmentType);
        lenient().when(mockSegment.location()).thenReturn(loc);
        return mockSegment;
    }

    private Map<WallSegmentOrientation, Map<Coordinate3d, WallSegment>> populatedMap(
            WallSegment... segments) {
        Map<WallSegmentOrientation, Map<Coordinate3d, WallSegment>> segmentsMap = mapOf();
        // GameZone::getSegments is assumed to return a non-null map for each orientation
        segmentsMap.put(HORIZONTAL, mapOf());
        segmentsMap.put(CORNER, mapOf());
        segmentsMap.put(VERTICAL, mapOf());
        for (var segment : segments) {
            segmentsMap.get(segment.getType().orientation()).put(segment.location(), segment);
        }
        return segmentsMap;
    }

    // NB: With excessively high or low values, the floating point calculations used to calculate
    // the tiles covered by a visibility ray no longer work properly, due to floating point
    // rounding issues. This isn't an issue in practice, since no GameZone should need more than
    // 100,000,000 tiles, so this range should be adequate for testing.
    private Coordinate3d randomCoordinate3dInNormalRangeAtZ() {
        return Coordinate3d.of(
                randomIntInRange(-10000, 10000),
                randomIntInRange(-10000, 10000),
                Z
        );
    }

    @Test
    public void testGetInterfaceName() {
        assertEquals(TileVisibilityRayCalculation.class.getCanonicalName(),
                rayCalculation.getInterfaceName());
    }
}
